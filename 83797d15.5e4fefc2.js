(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{193:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return p}));var a=n(2),r=n(11),i=(n(0),n(241)),l={id:"languagedetails",title:"Language Details",sidebar_label:"Language Details"},s={id:"languagedetails",isDocsHomePage:!1,title:"Language Details",description:"This doc describes the Dark language. Dark is really a system - a combination of",source:"@site/docs/languagedetails.md",permalink:"/languagedetails",sidebar_label:"Language Details",sidebar:"docs",previous:{title:"Functional Aspects",permalink:"/functional-aspects"},next:{title:"Datastores",permalink:"/datastores"}},o=[{value:"Type system",id:"type-system",children:[]},{value:"Built-in types",id:"built-in-types",children:[{value:"Integers",id:"integers",children:[]},{value:"Floats",id:"floats",children:[]},{value:"Booleans",id:"booleans",children:[]},{value:"Strings",id:"strings",children:[]},{value:"Characters",id:"characters",children:[]},{value:"Lists/Arrays",id:"listsarrays",children:[]},{value:"Binary",id:"binary",children:[]},{value:"Options",id:"options",children:[]},{value:"Results",id:"results",children:[]},{value:"Dicts",id:"dicts",children:[]},{value:"UUID",id:"uuid",children:[]},{value:"Null",id:"null",children:[]}]},{value:"User defined types",id:"user-defined-types",children:[{value:"Records",id:"records",children:[]},{value:"Enums",id:"enums",children:[]}]},{value:"Types unique to Dark",id:"types-unique-to-dark",children:[{value:"Incompletes",id:"incompletes",children:[]},{value:"Error rail",id:"error-rail",children:[]},{value:"Sensitive Types",id:"sensitive-types",children:[]}]},{value:"Expressions",id:"expressions",children:[{value:"Let",id:"let",children:[]},{value:"If",id:"if",children:[]},{value:"Match",id:"match",children:[]},{value:"Functions",id:"functions",children:[]},{value:"Lambda",id:"lambda",children:[]},{value:"Pipelining",id:"pipelining",children:[]},{value:"Feature Flags",id:"feature-flags",children:[]}]},{value:"Planned language features",id:"planned-language-features",children:[{value:"Tuples",id:"tuples",children:[]},{value:"Sets",id:"sets",children:[]},{value:"Unit",id:"unit",children:[]},{value:"Imperative programming (Statements and refs)",id:"imperative-programming-statements-and-refs",children:[]}]}],c={rightToc:o};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"This doc describes the Dark language. Dark is really a system - a combination of\nthe language, editor, framework and infrastructure. In this doc, we'll focus on\ndiscussing the language itself, ignoring where possible the editor and\ninfrastructure."),Object(i.b)("p",null,"This discusses both the language and the ",Object(i.b)("strong",{parentName:"p"},"intended")," language. We have taken\nmany shortcuts to be able to ship Dark, and so many parts of the language are\nnot currently at their end state. Here we discuss both what the language is, and\nwhat we intend it to be."),Object(i.b)("p",null,"Dark is a statically-typed functional/imperative hybrid, based loosely on ML. It\nis a high-level language, with immutable values, garbage collection, and support\nfor generics/polymorphic types."),Object(i.b)("p",null,"Dark is somewhat similar to OCaml or Elm. It has many similarities to Rust and\nHaskell, and is also influenced by Clojure, Ruby, Python, CoffeeScript, as well\nas our experience with (alphabetically) Bash, C, Clojure, CoffeeScript, C++,\nElm, Javascript, Java, Haskell, OCaml, Perl, PHP, Python, ReasonML, Ruby/Rails,\nReact, and Rust."),Object(i.b)("h3",{id:"type-system"},"Type system"),Object(i.b)("p",null,"Dark\u2019s type system is most similar to Elm, Haskell, ReasonML, OCaml or Rust:\nbased on records, enums, list, and built-in generics/polymorphism. All values in\nDark are immutable, except refs."),Object(i.b)("p",null,"Dark has some standard basic types: ",Object(i.b)("inlineCode",{parentName:"p"},"int"),", ",Object(i.b)("inlineCode",{parentName:"p"},"string"),", ",Object(i.b)("inlineCode",{parentName:"p"},"boolean"),", ",Object(i.b)("inlineCode",{parentName:"p"},"float"),", ",Object(i.b)("inlineCode",{parentName:"p"},"list"),",\nand ",Object(i.b)("inlineCode",{parentName:"p"},"dicts"),"."),Object(i.b)("p",null,"We support typical functional types: ",Object(i.b)("inlineCode",{parentName:"p"},"Option")," and ",Object(i.b)("inlineCode",{parentName:"p"},"Result"),"."),Object(i.b)("p",null,"Currently, Dark has a ",Object(i.b)("inlineCode",{parentName:"p"},"null")," type to support JSON values directly. In the\nfuture, we intend to deprecate ",Object(i.b)("inlineCode",{parentName:"p"},"null")," and replace it with ",Object(i.b)("inlineCode",{parentName:"p"},"Options"),"."),Object(i.b)("h2",{id:"built-in-types"},"Built-in types"),Object(i.b)("h3",{id:"integers"},"Integers"),Object(i.b)("p",null,"Integers are signed 63-bit integer."),Object(i.b)("p",null,"In the future, Dark will use infinite-precision integers. We also intend to add\nunsigned 8-bit integers and bit-manipulation functions."),Object(i.b)("h3",{id:"floats"},"Floats"),Object(i.b)("p",null,"Floats are double-precision 64-bit floating-point values (IEEE 754)."),Object(i.b)("p",null,"We intend for numeric operations to return Results, to handle situations which\nare undefined on the datatype. For example, integer division would return\n",Object(i.b)("inlineCode",{parentName:"p"},"Result Error Int"),". Similarly, floating point values would never be ",Object(i.b)("inlineCode",{parentName:"p"},"NaN"),", and\ninstead would return ",Object(i.b)("inlineCode",{parentName:"p"},"Result Error Float"),". See\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"error-handling"}),"Error Handling in Dark")," for more."),Object(i.b)("h3",{id:"booleans"},"Booleans"),Object(i.b)("p",null,"Booleans are true or false."),Object(i.b)("h3",{id:"strings"},"Strings"),Object(i.b)("p",null,"Strings are unicode, and character are unicode \u201ccharacters\u201d (if it appears as\none character on the screen, that\u2019s a \u201ccharacter\u201d in Dark)."),Object(i.b)("p",null,"Specifically, string are immutable UTF-8 encoded sequences of Unicode code\npoints. Chars are \u201cExtended Grapheme Clusters\u201d. (A codepoint is some bytes that\nimplement unicode characters, a grapheme is some codepoints forming a unicode\nentity, such as an emoji; an EGC is some graphemes, used to handle things like\nemojis which combine to form a single emoji)."),Object(i.b)("p",null,"Dark doesn't currently support string interpolation, but we plan to in the\nfuture."),Object(i.b)("h3",{id:"characters"},"Characters"),Object(i.b)("p",null,"In the future, Dark will support individual characters."),Object(i.b)("h3",{id:"listsarrays"},"Lists/Arrays"),Object(i.b)("p",null,"Lists and Arrays use the same datatype, called Lists. The Dark compiler will in\nthe future optimize their implementation to support good algorithmic complexity\nand performance for whatever you use them for."),Object(i.b)("p",null,"Lists should be used for all \u201cI want a sequence of things\u201d situations, including\niterating across them, random access, push/pop, etc."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"let x = [8]\nlet y = List::append x [6]\ny\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"[8, 6]\n")),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/docs/img/language/list_example.png",alt:"List Example"}))),Object(i.b)("h3",{id:"binary"},"Binary"),Object(i.b)("p",null,"Non-unicode sequences of bytes are supported as the ",Object(i.b)("inlineCode",{parentName:"p"},"Binary")," type."),Object(i.b)("h3",{id:"options"},"Options"),Object(i.b)("p",null,"Instead of allowing all values to potentially be null, as in most imperative\nlanguages, Dark uses an Option type:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"Option a = Just a | Nothing\n")),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/docs/img/language/option_example.png",alt:"Option Example"}))),Object(i.b)("p",null,"This is intended to convert effortlessly to null in JSON, but we don't quite\nhave enough of the type system to remove null, so they both exist right now."),Object(i.b)("p",null,"Functions which return ",Object(i.b)("inlineCode",{parentName:"p"},"Option")," trigger the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"error-handling"}),"Error Rail"),"."),Object(i.b)("h3",{id:"results"},"Results"),Object(i.b)("p",null,"Any functions which can have an error should use Results. We use results for Int\ndivision, Float operations, HTTP operations, etc."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"Result a = Ok a | Err Error\n")),Object(i.b)("p",null,"Dark has no exceptions - all errors go through Results. See\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"error-handling"}),"error handling")," for more details."),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/docs/img/language/result_example.png",alt:"Result Example"}))),Object(i.b)("h3",{id:"dicts"},"Dicts"),Object(i.b)("p",null,"Dicts are maps from a certain key type to a certain value type. The key must\ncurrently be a string. The value can be any type but all elements of the Dict\nare the same type (not currently enforced)."),Object(i.b)("p",null,"Dicts are different than records: dicts can have arbitrary keys."),Object(i.b)("h3",{id:"uuid"},"UUID"),Object(i.b)("p",null,"Dark supports UUIDs directly."),Object(i.b)("h3",{id:"null"},"Null"),Object(i.b)("p",null,"As a temporary hack, Dark also supports ",Object(i.b)("inlineCode",{parentName:"p"},"null"),". This allows us handle JSON while\nwe build out enough type-system support to allow them to be replaced by\n",Object(i.b)("inlineCode",{parentName:"p"},"Option"),"."),Object(i.b)("p",null,"Null is mostly useful for comparing against incoming JSON and results of\nHttpClient calls. When returning JSON or making HttpClient calls, you can use\nOptions instead and they will be converted properly to ",Object(i.b)("inlineCode",{parentName:"p"},"null")," in the JSON\noutput."),Object(i.b)("h2",{id:"user-defined-types"},"User defined types"),Object(i.b)("p",null,"Dark currently has limited support for user-defined types. Currently, we support\ninline definition of records, but do not support defining record types\nexplicitly."),Object(i.b)("p",null,"Record types are actually implemented under the hood, and we intend to use them\nto support typed Datastores, API contracts, and static types."),Object(i.b)("p",null,"Dark does not currently support user-defined enums."),Object(i.b)("p",null,"User-defined types will be either records or enums, or combinations of other\ntype expressions."),Object(i.b)("p",null,"Types in Dark are out-of-line, meaning that they are not defined \u201con the\ncanvas\u201d, in a similar way to functions."),Object(i.b)("p",null,"All types in Dark will be versioned."),Object(i.b)("p",null,"In the future, we intend to support typeclasses or traits to allow ad-hoc\npolymorphism."),Object(i.b)("h3",{id:"records"},"Records"),Object(i.b)("p",null,"Records are most akin to Classes in an imperative language."),Object(i.b)("p",null,"Records are a set of keys and values. Each key name and type are defined, and\nthe types do not have to be the same."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),'let x = { name: "Robin"\n          age: 32\n          gender: "Other"\n        }\n')),Object(i.b)("p",null,"Records can not be accessed dynamically; they are not Maps/Hashtables/Dicts."),Object(i.b)("p",null,"Records are structurally typed, and are equivalent to records of the same shape\nbut a different name."),Object(i.b)("p",null,"Note that at the moment, Dicts and Records share the same implementation and can\nbe accessed and modified in the same way. We intend to break these apart in the\nfuture."),Object(i.b)("h3",{id:"enums"},"Enums"),Object(i.b)("p",null,"Enums are a set of \u201cconstructors\u201d, each of which has a set of typed arguments."),Object(i.b)("p",null,"Currently, Dark only supports ",Object(i.b)("inlineCode",{parentName:"p"},"Option")," and ",Object(i.b)("inlineCode",{parentName:"p"},"Result")," built-in enums. In the\nfuture, we will support user-defined enums."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"type Person = Human {age: Int, name: String, itin: String }\n            | Corporation {age: Int, name: String, ein: String }\n            | Puppers Int String\n")),Object(i.b)("p",null,"Enums can be made by building on existing types, especially records and other\nenums."),Object(i.b)("p",null,"Enums are nominally typed. (Two enums with the same field names and types are\nnot equivalent)."),Object(i.b)("h2",{id:"types-unique-to-dark"},"Types unique to Dark"),Object(i.b)("h3",{id:"incompletes"},"Incompletes"),Object(i.b)("p",null,"Programs in Dark start as a single empty expression. As they get built up in our\nstructured editor, they can never become syntactically invalid. However, a\nprogram may be incomplete if any its expressions are empty."),Object(i.b)("p",null,"An empty expression is incomplete. A developer may write programs where some\nparts are incomplete as they build out the code. As such, incomplete values\nappear dynamically when the code is executed. Structures containing incompletes\nare themselves incomplete. For example functions with incomplete arguments do\nnot execute, and return incomplete; and records with an incomplete field are\nalso incomplete."),Object(i.b)("p",null,"Incompletes are never returned to end users, and cannot be stored in a\ndatastore. Returning an incomplete via a HTTP handler causes a 500 error."),Object(i.b)("h3",{id:"error-rail"},"Error rail"),Object(i.b)("p",null,"You might occasionally see a value marked ",Object(i.b)("inlineCode",{parentName:"p"},"<ErrorRail>"),", this is used to\nindicate that a value is on the Error Rail. See\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://medium.com/darklang/real-problems-with-functional-languages-efe668c5264a"}),"Railway Oriented Programming"),"\nfor more details."),Object(i.b)("h3",{id:"sensitive-types"},"Sensitive Types"),Object(i.b)("p",null,"Some values are sensitive, for example, passwords or credit card numbers."),Object(i.b)("p",null,"Currently Dark supports the ",Object(i.b)("inlineCode",{parentName:"p"},"Password")," type, which is never saved directly or\nsent to the editor."),Object(i.b)("p",null,"In the future, Dark will allow you to specify types of sensitive values,\npreventing them from being stored in logs, and allowing a team to limit who has\naccess to these values in the Dark editor."),Object(i.b)("h2",{id:"expressions"},"Expressions"),Object(i.b)("p",null,"All Dark language constructs are expressions. That means that they evaluate to a\nvalue, rather than being used to set state."),Object(i.b)("h3",{id:"let"},"Let"),Object(i.b)("p",null,"Lets creates a name with an immutable value, and a scope in which that is\ndefined."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),'let name = "Stella"\nname\n')),Object(i.b)("p",null,"We often refer to these names as variables, for simplicity. However, they never\nvary: once they are defined, they never have any other value."),Object(i.b)("h4",{id:"variable-scope"},"Variable Scope"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"if age > 18\nthen\n  let height = 170\n  height + 12\nelse\n  let weight = 105\n  weight / 2\n")),Object(i.b)("p",null,"In the example above, the scope of ",Object(i.b)("inlineCode",{parentName:"p"},"height")," and ",Object(i.b)("inlineCode",{parentName:"p"},"weight")," only extends to within\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"then")," block and ",Object(i.b)("inlineCode",{parentName:"p"},"else")," block respectively. You cannot use either variable\nbelow the ",Object(i.b)("inlineCode",{parentName:"p"},"if")," expression."),Object(i.b)("p",null,"See doc on ",Object(i.b)("inlineCode",{parentName:"p"},"coding in an expression-based language"),"."),Object(i.b)("h3",{id:"if"},"If"),Object(i.b)("p",null,"Dark supports if/else statement. The argument to an ",Object(i.b)("inlineCode",{parentName:"p"},"if")," is a boolean. We\ncurrently support ",Object(i.b)("inlineCode",{parentName:"p"},"truthy")," types but intend to remove that ability."),Object(i.b)("p",null,"We support ",Object(i.b)("inlineCode",{parentName:"p"},"&&")," and ",Object(i.b)("inlineCode",{parentName:"p"},"||")," - they do not currently short-circuit but we intend\nthem to in the future."),Object(i.b)("p",null,"An ",Object(i.b)("inlineCode",{parentName:"p"},"if")," is not currently allowed without a corresponding ",Object(i.b)("inlineCode",{parentName:"p"},"else")," - we will relax\nthis after we introduce statements."),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/docs/img/language/if_example.png",alt:"If Example"}))),Object(i.b)("h3",{id:"match"},"Match"),Object(i.b)("p",null,"Dark supports pattern matching, in particular, matching on ",Object(i.b)("inlineCode",{parentName:"p"},"Enum"),"s."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ocaml"}),'let introduction =\n  match name with\n  | Nothing -> "Hi!"\n  | Just name -> "Dear " ++ name\n')),Object(i.b)("p",null,"We expect to allow guards in the future. We also hope to add an ",Object(i.b)("inlineCode",{parentName:"p"},"if-let"),"\nconstruct to support ",Object(i.b)("inlineCode",{parentName:"p"},"if")," statements that destructure from Enums."),Object(i.b)("h3",{id:"functions"},"Functions"),Object(i.b)("p",null,"Functions must have type declarations for inputs. We intend to support types on\nreturn values soon."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"fetch url name =\n  { url: url\n  , name: name\n  }\n")),Object(i.b)("p",null,"Functions in Dark are simple, and do not currently support functional language\nconcepts, such as partial application, functions as first-class values, and\ndefining functions in using points-free style."),Object(i.b)("p",null,"Functions do not live in the \u201cCanvas\u201d, but rather are a little bit ethereal."),Object(i.b)("p",null,"Built-in functions are all versioned: we frequently deprecate old functions and\nadd updates. When we deprecate old versions, your code does ",Object(i.b)("em",{parentName:"p"},"not")," change, and\nyou keep using the old ones. We intend to support automated refactoring and\nupdating in the future."),Object(i.b)("p",null,"In the future, we intend to support partial application/currying, and\ndefault/optional parameters."),Object(i.b)("h3",{id:"lambda"},"Lambda"),Object(i.b)("p",null,"Lambdas are anonymous functions. They are used to pass to functions which take\n",Object(i.b)("inlineCode",{parentName:"p"},"Block"),"s, typically used for iteration."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"List::map [5, 10, 11] \\var -> var + 2\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"[7, 12, 13]\n")),Object(i.b)("p",null,"In the future, we intend to support a syntax for shorthands for creating lambdas\nto access fields: ",Object(i.b)("inlineCode",{parentName:"p"},".fieldname"),". This can be included in a pipe or used as a\nfirst class function."),Object(i.b)("p",null,"We also intend to support passing functions where blocks are expected."),Object(i.b)("p",null,"There is a syntax for shorthands for creating lambda\u2019s to call constructors:\n",Object(i.b)("inlineCode",{parentName:"p"},"ConstructorName"),". This can be included in a pipe or used as a first class\nfunction."),Object(i.b)("h3",{id:"pipelining"},"Pipelining"),Object(i.b)("p",null,"Dark programs are intended to be written, as much as possible, as pipelines of\ndata:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),'user\n|> getFriends\n|> List.map (\\f -> (f, getFriends f))\n|> List.filter (\\f -> f.name == "Kevin Bacon")\n|> (=) []\n')),Object(i.b)("h3",{id:"feature-flags"},"Feature Flags"),Object(i.b)("p",null,"Feature flags are similar to ",Object(i.b)("inlineCode",{parentName:"p"},"if"),"s:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"flag myCondition\nthen 5\nelse 6\n")),Object(i.b)("p",null,"However, flags differ slightly from ifs in that any condition that is not ",Object(i.b)("inlineCode",{parentName:"p"},"true"),"\nwill cause the ",Object(i.b)("inlineCode",{parentName:"p"},"then")," block to activate. This is especially important around\n",Object(i.b)("inlineCode",{parentName:"p"},"incomplete"),"s, allowing you to take working code and edit the feature flag\nwithout disturbing existing users. In an ",Object(i.b)("inlineCode",{parentName:"p"},"if")," statement, neither branch would\nexecute."),Object(i.b)("h2",{id:"planned-language-features"},"Planned language features"),Object(i.b)("h3",{id:"tuples"},"Tuples"),Object(i.b)("p",null,"Dark intends to support tuples: lists of defined length supporting heterogeneous\ntypes."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),'x = (1, "string", { name: "Sam" })\n')),Object(i.b)("h3",{id:"sets"},"Sets"),Object(i.b)("p",null,"We intend for Dark to support Sets: unordered collections of a single type."),Object(i.b)("h3",{id:"unit"},"Unit"),Object(i.b)("p",null,"We intend to support the unit type, which indicates something that have no type,\nsuch as an imperative function that doesn't return anything."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-elm"}),"x = ()\n")),Object(i.b)("h3",{id:"imperative-programming-statements-and-refs"},"Imperative programming (Statements and refs)"),Object(i.b)("p",null,"It is intended that you write the program as you think it, not to shoehorn your\nprogram into a functional style. As such, Dark is planning to add a number of\nimperative concepts to allow you to easily write imperative algorithms,\nincluding statements, refs, and mutable data structures."))}p.isMDXComponent=!0},241:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(n),d=a,m=u["".concat(l,".").concat(d)]||u[d]||b[d]||i;return n?r.a.createElement(m,s(s({ref:t},c),{},{components:n})):r.a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:a,l[1]=s;for(var c=2;c<i;c++)l[c]=n[c];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);