(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{192:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return d}));var i=n(2),r=n(11),a=(n(0),n(242)),o={title:"General concepts"},s={id:"contributing/general-concepts",isDocsHomePage:!1,title:"General concepts",description:"Editor vs Production (how code runs)",source:"@site/docs/contributing/general-concepts.md",permalink:"/contributing/general-concepts",sidebar:"Contributing",previous:{title:"ReScript and F# for Dark developers",permalink:"/contributing/ocaml-for-dark-developers"},next:{title:"A tour of the Editor",permalink:"/contributing/tour-of-editor"}},l=[{value:"Editor vs Production (how code runs)",id:"editor-vs-production-how-code-runs",children:[]},{value:"Traces &amp; Live values",id:"traces--live-values",children:[]},{value:"Toplevels",id:"toplevels",children:[]},{value:"The path of an edit",id:"the-path-of-an-edit",children:[{value:"Sending the change to the server",id:"sending-the-change-to-the-server",children:[]}]},{value:"ASTs",id:"asts",children:[]}],c={rightToc:l};function d(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"editor-vs-production-how-code-runs"},"Editor vs Production (how code runs)"),Object(a.b)("p",null,"Code runs in two places in Dark, in the Editor, and in Production. In\nproduction, we have a Kubernetes cluster of interpreters with HTTP servers which\nare connected to a database, connected to the internet via Google Cloud\ninfrastructure, that run Dark programs."),Object(a.b)("p",null,'When requests are made in production we save their inputs and intermediate\nvalues (combined, these form a "trace", discussed below). Those are sent to the\nclient.'),Object(a.b)("p",null,"The Dark interpreter is also compiled to Javascript and is available in the\nbrowser in the client. The traces are sent to the JS-compiled interpreter, which\nuses their results to fill in for functions which can't be run on the client\n(such as DB functions)."),Object(a.b)("h2",{id:"traces--live-values"},"Traces & Live values"),Object(a.b)("p",null,"When a request is made to a production server, the inputs (typically a HTTP\nrequest) are saved. We also save intermediate results of functions which are\ncalled during the request. Together, these comprise a trace. Traces are shown in\nthe editor and users can choose between them."),Object(a.b)("h2",{id:"toplevels"},"Toplevels"),Object(a.b)("p",null,'"Toplevel" is the generic name for a part of a Dark program, either a handler\n(whether a HTTP handler, a Cron or a worker), a function, a type, or a database.'),Object(a.b)("p",null,"Structural toplevels are toplevels which are part of the structure of your\nprogram: handlers and DBs. These live on the canvas."),Object(a.b)("p",null,'Other toplevels are non-structural, and they don\'t live on the canvas or really\nanywhere. We have started to affectionately refer to the display for these as\nthe "function space". (There is a design for what should happen here, but we\nhave not done it yet).'),Object(a.b)("h2",{id:"the-path-of-an-edit"},"The path of an edit"),Object(a.b)("p",null,'Most characters that you type are immediately saved in our production database\n(in, according to our claim, 50ms). Edits are either made to program code, which\nis part of the "Fluid" editing system, or to handlers, databases, function\nparameters, or similar metadata, which is part of the "Forms" editing system\n(originally, all edits were of the "forms" variety - the name was added post-hoc\nto differentiate it from "fluid").'),Object(a.b)("p",null,"For Fluid, this is the journey:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"the event processed by ",Object(a.b)("inlineCode",{parentName:"li"},"FluidKeyboard.ml"),", creating a ",Object(a.b)("inlineCode",{parentName:"li"},"FluidMsg")),Object(a.b)("li",{parentName:"ul"},"Fluid.ml recognized the ",Object(a.b)("inlineCode",{parentName:"li"},"FluidMsg"),", calling ",Object(a.b)("inlineCode",{parentName:"li"},"updateKey")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"updateKey"),' looks at the current caret position, and at the "tokens" before\nand after the caret, to figure out what\'s happening'),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"updateKey")," makes a transformation based on whatever it decided"),Object(a.b)("li",{parentName:"ul"},"the AST for that code is transformed"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"FluidAutocomplete")," may be regenerated, if necessary"),Object(a.b)("li",{parentName:"ul"},'the browser\'s animation event fires, causing a re-render. The AST is\n"tokenized", essentially pretty-printing it as HTML, which then renders'),Object(a.b)("li",{parentName:"ul"},"an API call is made to send the change to the server (detailed below)")),Object(a.b)("p",null,"For forms, the journey is similar:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"the event is processed by ",Object(a.b)("inlineCode",{parentName:"li"},"KeyPress.ml")),Object(a.b)("li",{parentName:"ul"},"the contents of ",Object(a.b)("inlineCode",{parentName:"li"},"m.complete.value")," are updated (this is where the value in the\nforms box is stored)"),Object(a.b)("li",{parentName:"ul"},"the ",Object(a.b)("inlineCode",{parentName:"li"},"Autocomplete")," values are regenerated"),Object(a.b)("li",{parentName:"ul"},"after pressing enter, or clicking away, the change is made"),Object(a.b)("li",{parentName:"ul"},"an API call is made to send the change to the server (detailed below)")),Object(a.b)("h3",{id:"sending-the-change-to-the-server"},"Sending the change to the server"),Object(a.b)("p",null,"When a change is made, typically an ",Object(a.b)("inlineCode",{parentName:"p"},"AddOp")," ",Object(a.b)("inlineCode",{parentName:"p"},"modification")," is made. That\n",Object(a.b)("inlineCode",{parentName:"p"},"modification")," is returned by many of the functions that edit programs, and it's\nprocessed in ",Object(a.b)("inlineCode",{parentName:"p"},"Main.ml"),". This passes into ",Object(a.b)("inlineCode",{parentName:"p"},"API.ml"),", where it serializes the ",Object(a.b)("inlineCode",{parentName:"p"},"Op"),"\nchange into a JSON via encoders (see ",Object(a.b)("inlineCode",{parentName:"p"},"Enconders.ml")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Decoders.ml"),")."),Object(a.b)("p",null,"The change is accepted by ",Object(a.b)("inlineCode",{parentName:"p"},"api.ml")," in the backend, where it is decoded, applied\nto the program, and then saved into the database. Saving the program involves a\nspecial binary serialization format, in ",Object(a.b)("inlineCode",{parentName:"p"},"Serialization_format.ml"),"."),Object(a.b)("p",null,"After being saved, it is sent to ",Object(a.b)("inlineCode",{parentName:"p"},"Stroller"),', a "sidecar" process in Rust that\nsends it to Pusher.com, the websockets vendor we use. This is sent to other\nclients which then update their programs. It is also sent to the original\neditor, who ignores it.'),Object(a.b)("h2",{id:"asts"},"ASTs"),Object(a.b)("p",null,'An "AST" is an "Abstract syntax tree". The simple explanation is that it\'s a set\nof "classes" and "objects" representing programs. (Abstract syntax tree means\nthe programs representation (the "syntax tree") without the annoying syntactic\ndetails like commas and semi-colons (hence "abstract")).'),Object(a.b)("p",null,"In Dark, it's defined in ",Object(a.b)("inlineCode",{parentName:"p"},"FluidExpression.ml"),", and at time of writing looks like\nthis:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-ocaml"}),"type sendToRail =\n  | Rail\n  | NoRail\n\ntype expr  =\n  | EInteger of id * string\n  | EBool of id * bool\n  | EString of id * string\n  | EFloat of id * string * string\n  | ENull of id\n  | EBlank of id\n  | ELet of id * string * expr * expr\n  | EIf of id * expr * expr * expr\n  | EBinOp of id * string * expr * expr * sendToRail\n  | ELambda of id * (id * string) list * expr\n  | EFieldAccess of id * expr * string\n  | EVariable of id * string\n  | EFnCall of id * string * expr list * sendToRail\n\n  | EPartial of id * string * expr\n  | ERightPartial of id * string * expr\n  | ELeftPartial of id * string * expr\n  | EList of id * expr list\n  | ERecord of id * (string * expr) list\n  | EPipe of id * expr list\n  | EConstructor of id * string * expr list\n  | EMatch of id * expr * (pattern * expr) list\n  | EPipeTarget of id\n  | EFeatureFlag of id * string * expr * expr * expr\n\ntype pattern =\n  | FPVariable of id * id * string\n  | FPConstructor of id * id * string * pattern list\n  | FPInteger of id * id * string\n  | FPBool of id * id * bool\n  | FPString of id * id * string\n  | FPFloat of id * id * string * string\n  | FPNull of id * id\n  | FPBlank of id * id\n")),Object(a.b)("p",null,"These definitions are in ReScript (we have a\n",Object(a.b)("a",Object(i.a)({parentName:"p"},{href:"/contributing/ocaml-for-dark-developers"}),"guide to ReScript for Dark developers"),"). Briefly,\nthis means that an ",Object(a.b)("inlineCode",{parentName:"p"},"expr")," is an integer (which is made up of an id and a string)\nor a bool (made up of an id and a string), or a ",Object(a.b)("inlineCode",{parentName:"p"},"match")," (which is an id, an\nexpression to match on, and a list of patterns and expressions), etc"),Object(a.b)("p",null,"This definition is slightly simplified, but it's close. There's definitions for\nliterals like ints and strings, for definitions like ",Object(a.b)("inlineCode",{parentName:"p"},"let"),"s, for function calls\nwith ",Object(a.b)("inlineCode",{parentName:"p"},"EBinOp")," and ",Object(a.b)("inlineCode",{parentName:"p"},"EFnCall"),", and also for various editor-specific intermediate\nstates like ",Object(a.b)("inlineCode",{parentName:"p"},"EPartial")," and ",Object(a.b)("inlineCode",{parentName:"p"},"ERightPartial"),"."),Object(a.b)("p",null,"Each expression has an ",Object(a.b)("inlineCode",{parentName:"p"},"id")," that is used to uniquely refer to the expression.\nThis is used when editing programs, and to relate live values from the analysis\nengine to the display in the editor. If an ID is duplicated by accident, the\neditor will act weirdly, but the program will work fine."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"FluidPattern.ml")," and ",Object(a.b)("inlineCode",{parentName:"p"},"FluidExpression.ml")," also contain functions for changing\npatterns and expressions easily, either by changing the by ID or by traversing\nacross the entire structure. Traversing the structure is generally pretty fast."))}d.isMDXComponent=!0},242:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var i=n(0),r=n.n(i);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),d=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=d(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(n),u=i,h=p["".concat(o,".").concat(u)]||p[u]||b[u]||a;return n?r.a.createElement(h,s(s({ref:t},c),{},{components:n})):r.a.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=n[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);